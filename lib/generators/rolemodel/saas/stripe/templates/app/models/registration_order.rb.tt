# frozen_string_literal: true

class RegistrationOrder < ApplicationRecord
  belongs_to :user
  belongs_to :<%= @key_model_names[:singular] %>, optional: true
  belongs_to :promotional_code, optional: true

  has_many :registration_items
  <% if @ticket_needed %>has_many :ticket_items<% end %>
  has_many :refunds

  validates :user, presence: true

  scope :paid, -> { where.not(transaction_id: nil) }
  scope :order_by_user_names, -> { includes(:registration_items, :user).order('users.name asc') }

  EMPTY_TRANSACTION_ID = '-1'

  def paid?
    transaction_id.present?
  end

  def finalize!(transaction_id, price)
    update(
      payment_processor: transaction_id ? 'stripe' : nil,
      transaction_id: transaction_id || -1, # negative id for zero-dollar invoices w/o gateway representation
      base_price: price.base_price,
      convenience_fees: price.total_convenience_fees,
      processing_fees: price.total_processing_fees,
      purchase_total: price.total_price
    )

    registration_items.each do |item|
      item.record_pricing!
    end
  end

  def name
    return <%= @key_model_names[:singular] %>.name if <%= @key_model_names[:singular] %>?

    "Order #: #{padded_id}"
  end

  def <%= @key_model_names[:singular] %>?
    <%= @key_model_names[:singular] %>_id?
  end

  def refund!(convenience_fees_refunded = 0)
    update(
      base_price: registration_items.where(refunded_amount: 0).sum(&:recorded_price).round(2),
      refunded_convenience_fees: convenience_fees_refunded
    )
  end

  def padded_id
    format('%08d', id)
  end
<% if @ticket_needed %>
  def tickets_ordered
    ticket_items.sum { |item| !item.refunded? ? item.quantity : 0 }
  end
<% end %>
  def completely_refunded?
    base_price == 0.0
  end
end
